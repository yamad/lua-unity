#!/usr/bin/env lua
-- generate_test_runner.lua
--   generates C test runner code from a Unity-based C test file
--
--   lua port of ruby code `generate_test_runner.rb` from the Unity C unit test framework
--   see http://throwtheswitch.org

-- TODO:
-- - "use_param_tests" option
--    - this appears to be a way to reuse tests, although I don't yet
--    - see the benefit over defining a non-test helper function with
--    - parameters.

function generate_test_runner(src_lines, options, filename)
   options = options or {}
   filename = filename or "stdin"

   local tests = find_tests(src_lines, options)
   local testfile_includes = find_includes(src_lines)
   local mocks = find_mocks(testfile_includes)
   local out = generate_runner_contents(filename, tests, mocks, options)
   return out, tests, testfile_includes, used_mocks
end

function input_to_lines(stream_in)
   local a = {}
   for line in stream_in:lines() do
      a[#a+1] = line
   end
   return a
end

function find_tests(lines, options)
   options = options or {}
   local tests = {}
   local test_pat = string.gsub("%s*void%s+(PREFIX%S-)%s*%((.-)",
                                "PREFIX", options.test_prefix or "test_")
   for i, line in ipairs(lines) do
      tn, args = string.match(line, test_pat)
      if tn then
         tests[#tests+1] = create_test(tn, args, i)
      end
   end
   return tests
end

local include_loc_pat = "^%s*#include%s+\"(.+)%.[hH]\""
local include_global_pat = "^%s*#include%s+<(.+)%.[hH]>"
function find_includes(lines)
   local includes = {}
   for _, line in ipairs(lines) do
      inc = string.match(line, include_loc_pat) or string.match(line, include_global_pat)
      if inc then
         includes[inc] = true
      end
   end
   return includes
end

local mock_pat = "^mock"
function find_mocks(includes)
   local mocks = {}
   for inc in pairs(includes) do
      if string.match(inc, mock_pat) then
         mocks[inc] = true
      end
   end
   return mocks
end

function create_test(test_name, arguments, line_num)
   return {test_name=test_name, line_num=line_num, args=parse_args(arguments)}
end

function parse_args(arg_string)
   local args = {}
   _, j, a = string.find(arg_string, "([^%s,]+)%s*,?") -- get first argument
   if a then args[#args+1] = a end

   --  find remaining arguments
   j = j or 0
   for a in string.gmatch(string.sub(arg_string, j), "%s*,%s*(%S+)") do
      args[#args+1] = a
   end
   return args
end

function generate_runner_contents(filename, tests, mocks, options)
   options = options or {}
   local res = generate_header(mocks, options)
   extend_array(res, generate_externs(tests, options))
   extend_array(res, generate_mock_management(mocks, options))
   extend_array(res, generate_suite_setup_and_teardown(options))
   extend_array(res, generate_reset(mocks, options))
   extend_array(res, generate_main(filename, tests, options))
   return res
end

-- possible options:
--  includes: <list of extra includes>
--  plugins: <list of plugins>
--  enforce_string_ordering: <boolean>
function generate_header(mocks, options)
   options = options or {}
   local res = {}
   res[#res+1] = "/* AUTOGENERATED FILE. DO NOT EDIT. */"
   res = extend_array(res, generate_runtest(mocks, options))
   res[#res+1] = "//======= Automatically Detected Files To Include ====="
   res[#res+1] = "#include \"unity.h\""
   if not is_empty(mocks) then
      res[#res+1] = "#include \"cmock.h\""
   end
   if type(options.includes) == "table" then
      for include in pairs(options.includes) do
         res[#res+1] = string.format("#include %s", include)
      end
   end
   res[#res+1] = "#include <setjmp.h>"
   res[#res+1] = "#include <stdio.h>"
   if options.plugins and options.plugins["cexception"] then
      res[#res+1] = '#include "CException.h"'
   end
   for mock in pairs(mocks) do
      res[#res+1] = string.format("#include \"%s.h\"", mock)
   end
   if options.enforce_strict_ordering then
      res[#res+1] = ""
      res[#res+1] = "int GlobalExpectCount;"
      res[#res+1] = "int GlobalVerifyOrder;"
      res[#res+1] = "char* GlobalOrderError;"
   end
   return res
end

function generate_runtest(mocks, options)
   options = options or {}
   local res = {}

   local cexeption = nil
   if options.plugins and options.plugins["cexeption"] then
      cexeption = true
   end
   res[#res+1] = ""
   res[#res+1] = "//======= Test Runner Used To Run Each Test Below ====="
   res[#res+1] = "#define RUN_TEST(TestFunc, TestLineNum) \\"
   res[#res+1] = "{ \\"
   res[#res+1] = "  Unity.CurrentTestName = #TestFunc; \\"
   res[#res+1] = "  Unity.CurrentTestLineNumber = TestLineNum; \\"
   res[#res+1] = "  Unity.NumberOfTests++; \\"
   res[#res+1] = "  if (TEST_PROTECT()) \\"
   res[#res+1] = "  { \\"
   if cexeption then
      res[#res+1] = "    CEXCEPTION_T e; \\"
      res[#res+1] = "    Try { \\"
   end
   if not is_empty(mocks) then
      res[#res+1] = "      CMock_Init(); \\"
   end
   res[#res+1] = "      setUp(); \\"
   res[#res+1] = "      TestFunc(); \\"
   if not is_empty(mocks) then
      res[#res+1] = "      CMock_Verify(); \\"
   end
   if cexception then
      res[#res+1] = "    } Catch(e) { TEST_ASSERT_EQUAL_HEX32_MESSAGE(CEXCEPTION_NONE, e, \"Unhandled Exception!\"); } \\"
   end
   res[#res+1] = "  } \\"
   if not is_empty(mocks) then
      res[#res+1] = "  CMock_Destroy(); \\"
   end
   res[#res+1] = "  if (TEST_PROTECT() && !TEST_IS_IGNORED) \\"
   res[#res+1] = "  { \\"
   res[#res+1] = "    tearDown(); \\"
   res[#res+1] = "  } \\"
   res[#res+1] = "  UnityConcludeTest(); \\"
   res[#res+1] = "}\n"
   return res
end

function generate_externs(tests, options)
   options = options or {}
   local res = {}
   res[#res+1] = ""
   res[#res+1] = "//======= External Functions This Runner Calls ====="
   res[#res+1] = "extern void setUp(void);"
   res[#res+1] = "extern void tearDown(void);"
   for _,test in ipairs(tests) do
      res[#res+1] = string.format("extern void %s(void)", test.test_name)
   end
   return res
end

function generate_mock_management(mocks, options)
   options = options or {}
   local res = {}
   if not is_empty(mocks) then
      res[#res+1] = ""
      res[#res+1] = "//======= Mock Management ====="
      res[#res+1] = "static void CMock_Init(void)"
      res[#res+1] = "{"
      if options.enforce_strict_ordering then
         res[#res+1] = "  GlobalExpectCount = 0;"
         res[#res+1] = "  GlobalVerifyOrder = 0;"
         res[#res+1] = "  GlobalOrderError = NULL;"
      end
      for mock in pairs(mocks) do
         res[#res+1] = string.format("  %s_Init();", mock)
      end
      res[#res+1] = "}"
      res[#res+1] = ""
      res[#res+1] = "static void CMock_Verify(void)"
      res[#res+1] = "{"
      for mock in pairs(mocks) do
         res[#res+1] = string.format("  %s_Verify();", mock)
      end
      res[#res+1] = "}"
      res[#res+1] = ""
      res[#res+1] = "static void CMock_Destroy(void)"
      res[#res+1] = "{"
      for mock in pairs(mocks) do
         res[#res+1] = "  #{mock}_Destroy();"
      end
      res[#res+1] = "}"
   end
   return res
end

function generate_suite_setup_and_teardown(options)
   options = options or {}
   local res = {}
   if options.suite_setup then
      res[#res+1] = ""
      res[#res+1] = "//======= Suite Setup ====="
      res[#res+1] = "static int suite_setup(void)"
      res[#res+1] = "{"
      res[#res+1] = options.suite_setup
      res[#res+1] = "}"
   end
   if options.suite_teardown then
      res[#res+1] = ""
      res[#res+1] = "//======= Suite Teardown ====="
      res[#res+1] = "static int suite_teardown(int num_failures)"
      res[#res+1] = "{"
      res[#res+1] = options.suite_teardown
      res[#res+1] = "}"
   end
   return res
end

function generate_reset(mocks, options)
   options = options or {}
   local res = {}
   res[#res+1] = ""
   res[#res+1] = "//======= Test Reset Option ====="
   res[#res+1] = "void resetTest()"
   res[#res+1] = "{"
   if not is_empty(mocks) then
      res[#res+1] = "  CMock_Verify();"
      res[#res+1] = "  CMock_Destroy();"
   end
   res[#res+1] = "  tearDown();"
   if not is_empty(mocks) then
      res[#res+1] = "  CMock_Init();"
   end
   res[#res+1] = "  setUp();"
   res[#res+1] = "}"
   return res
end

-- options:
--   suite_setup: <setup code run before all tests>
--   suite_teardown: <clean up code run after all tests>
function generate_main(filename, tests, options)
   options = options or {}
   local res = {}
   res[#res+1] = ""
   res[#res+1] = ""
   res[#res+1] = "//======= MAIN ====="
   res[#res+1] = "int main(void)"
   res[#res+1] = "{"
   if options.suite_setup then
      res[#res+1] = "  suite_setup();"
   end
   res[#res+1] = string.format("  Unity.TestFile = \"%s\";", filename)
   res[#res+1] = "  UnityBegin();"

   for _, test in ipairs(tests) do
      res[#res+1] = string.format("  RUN_TEST(%s, %s);", test.test_name, test.line_num)
   end
   if options.suite_teardown then
      res[#res+1] = "  return suite_teardown(UnityEnd());"
   else
      res[#res+1] = "  return UnityEnd();"
   end
   res[#res+1] = "}"
   return res
end

function extend_array(a, b)
   -- add contents of table b to end of table a
   for _,v in ipairs(b) do
      a[#a+1] = v
   end
   return a
end

function is_empty(a)
   if next(a) == nil then return true end
   return false
end

function print_table(t,a)
   a = a or 0
   for i,v in pairs(t) do
      if type(v) == "table" then
         print_table(v,a+1)
      else
         print(a,i,v)
      end
   end
end


function gtr_main(options, stream_in, stream_out)
   stream_in = stream_in or io.stdin
   stream_out = stream_out or io.stdout

   local src = input_to_lines(stream_in)

   local runner_src = generate_test_runner(src, options)
   runner_src = table.concat(runner_src, "\n")
   stream_out:write(runner_src)
end
